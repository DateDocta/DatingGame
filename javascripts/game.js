// Generated by CoffeeScript 1.10.0
(function() {
  var Game, MatchMaker, Player, Utils;

  Player = require("./player");

  MatchMaker = require("./matchmaker");

  Utils = require("./utils");

  Game = (function() {
    function Game() {
      this.utils = new Utils;
      this.matchMaker = new MatchMaker(this);
      this.player = new Player(this);
      this.N = this.utils.N;
      this.waitingForMMCandidate = false;
      this.waitingForPCandidate = true;
      this.turn = 0;
      this.maxScore = -100;
    }

    Game.prototype.receivedCandidateFromMM = function(mmNumbers) {
      if (this.waitingForMMCandidate) {
        this.waitingForMMCandidate = false;
        this.currentMMCandidate = mmNumbers;
        return this.analyzeGame();
      }
    };

    Game.prototype.receivedCandidateFromP = function(pNumbers) {
      if (this.waitingForPCandidate) {
        this.waitingForPCandidate = false;
        this.currentPCandidate = mmNumbers;
        return this.analyzeGame();
      }
    };

    Game.prototype.updateMaxValues = function(score) {
      if (score > this.maxScore) {
        this.maxScore = score;
        this.maxScoreTurn = this.turn;
        this.maxMMVector = this.currentMMCandidate;
        return this.maxPVector = this.currentPCandidate;
      }
    };

    Game.prototype.analyzeGame = function() {
      var i, index, mmMessage, pMessage, randomCandidate, score;
      if (this.waitingForMMCandidate || this.waitingForPCandidate) {
        return;
      }
      if (this.turn === 0) {
        mmMessage = "";
        for (index = i = 1; i <= 20; index = ++i) {
          randomCandidate = createRandomCandidateForMM();
          mmMessage += scoredCandidateString(randomCandidate, this.currentPCandidate);
        }
        this.waitingForPCandidate = true;
        this.waitingForMMCandidate = true;
        this.turn += 1;
        return this.matchMaker.sendMessage(mmMessage);
      } else {
        this.turn += 1;
        score = scoreVector(this.currentMMCandidate, this.currentPCandidate);
        updateMaxValues(score);
        if (score === 1 || this.turn === 20) {
          return endGame();
        } else {
          pMessage = "continue";
          mmMessage = scoredCandidateString(this.currentMMCandidate, this.currentPCandidate);
          this.waitingForPCandidate = true;
          this.waitingForMMCandidate = true;
          this.turn += 1;
          this.matchMaker.sendMessage(mmMessage);
          return this.player.sendMessage(pMessage);
        }
      }
    };

    Game.prototype.endGame = function() {
      var endMessage, score;
      endMessage = "";
      endMessage += "Ultimate Score is (" + this.maxScore + ", " + this.turn + ")";
      endMessage += "Breakdown of Score\n";
      endMessage += "-----------------------------------\n\n";
      endMessage += "Turn of Max Score: " + this.maxScoreTurn + "\n";
      endMessage += "Max Score: " + this.maxScore + "\n";
      endMessage += "Matchmaker Candidate with Max Score: " + this.maxMMVector + "\n";
      endMessage += "Player Candidate at turn of Max Score: " + this.maxMMVector + "\n";
      endMessage += "\n\n";
      score = scoreVector(this.currentMMCandidate, this.currentPCandidate);
      endMessage += "Turn " + this.turn;
      endMessage += "Last Turn Score: " + score + "\n";
      endMessage += "Last Matchmaker Candidate: " + this.currentMMCandidate + "\n";
      endMessage += "Last Player Candidate: " + this.currentPCandidate + "\n";
      this.matchMaker.sendMessage("gameover");
      return this.player.sendMessage("gameover");
    };

    Game.prototype.scoreVector = function(vectorA, vectorB) {
      var score;
      return score = math.dot(vectorA, vectorB);
    };

    Game.prototype.scoredCandidateString = function(matchmakerCandidate, playerCandidate) {
      var i, len, number, returnString, score;
      if (playerCandidate == null) {
        playerCandidate = this.currentPCandidate;
      }
      returnString = "";
      score = scoreVector(matchmakerCandidate, playerCandidate);
      for (i = 0, len = matchmakerCandidate.length; i < len; i++) {
        number = matchmakerCandidate[i];
        returnString += number + " ";
      }
      returnString += "| " + score + "\n";
      return console.log(returnString);
    };

    Game.prototype.createRandomCandidateForMM = function() {
      var i, index, numberArray, ref;
      numberArray = [];
      for (index = i = 1, ref = this.N; 1 <= ref ? i <= ref : i >= ref; index = 1 <= ref ? ++i : --i) {
        numberArray.push(Math.random().toFixed(4));
      }
      return numberArray;
    };

    return Game;

  })();

}).call(this);
